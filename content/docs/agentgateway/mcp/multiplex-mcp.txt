---
title: Multiplex MCP
weight: 30
---

<!--TODO

Creating 2 HTTPRoutes on the same gateway makes the MCP inspector unable to connect.

Creating 1 HTTPRoute that refers to both Backends, the MCP inspector is able to connect but only lists the fetch tools.

It was still trying to connect to the fetcher when I deleted the Backend and HTTPRoute for the fetcher. I had to delete the Deploy and Service for the fetcher, and then the MCP inspector could connect again just to the verything tool.

-->

To federate multiple MCP servers on the same gateway, you can use a label selector in the MCP Backend.

This approach makes it easier for you to add more MCP servers by adding labels. It also lets your clients access tools from multiple MCP servers through a single endpoint and MCP connection.

{{< callout type="warning" >}}
Note that only streamable HTTP is currently supported for label selectors. If you have SSE, use a [static MCP Backend](#static).
{{< /callout >}}

## Before you begin

{{< reuse "docs/snippets/prereq-agw.md" >}}

## Step 1: Deploy MCP servers {#mcp-server-everythings}

Deploy multiple Model Context Protocol (MCP) servers that you want agentgateway to proxy traffic to. The following example sets up two MCP servers with different tools: one `npx` based MCP server that provides various utility tools and a `fetcher` tool.

1. Create an MCP server (`mcp-server-everything`) that provides various utility tools. Notice that the Service uses the `appProtocol: kgateway.dev/mcp` setting. This way, kgateway configures the agentgateway proxy to use MCP for the Backend that you create in the next step.

   ```yaml
   kubectl apply -f- <<EOF
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: mcp-server-everything
     labels:
       app: mcp-server-everything
   spec:
     replicas: 1
     selector:
       matchLabels:
         app: mcp-server-everything
     template:
       metadata:
         labels:
           app: mcp-server-everything
       spec:
         containers:
           - name: mcp-server-everything
             image: node:20-alpine
             command: ["npx"]
             args: ["-y", "@modelcontextprotocol/server-everything", "streamableHttp"]
             ports:
               - containerPort: 3001
   ---
   apiVersion: v1
   kind: Service
   metadata:
     name: mcp-server-everything
     labels:
       app: mcp-server-everything
   spec:
     selector:
       app: mcp-server-everything
     ports:
       - protocol: TCP
         port: 3001
         targetPort: 3001
         appProtocol: kgateway.dev/mcp
     type: ClusterIP
   EOF
   ```

2. Create a Backend that selects the MCP server that you just created.

   ```yaml
   kubectl apply -f- <<EOF
   apiVersion: gateway.kgateway.dev/v1alpha1
   kind: Backend
   metadata:
     name: mcp-server-everything
   spec:
     type: MCP
     mcp:
       name: mcp-virtual-server
       targets:
         - selectors:
             serviceSelector:
               matchLabels:
                 app: mcp-server-everything
   EOF
   ```

3. Create another MCP server workload with a fetcher tool.

   ```yaml
   kubectl apply -f- <<EOF
   apiVersion: apps/v1
   kind: Deployment
   metadata:
     name: mcp-website-fetcher
   spec:
     selector:
       matchLabels:
         app: mcp-website-fetcher
     template:
       metadata:
         labels:
           app: mcp-website-fetcher
       spec:
         containers:
         - name: mcp-website-fetcher
           image: ghcr.io/peterj/mcp-website-fetcher:main
           imagePullPolicy: Always
   ---
   apiVersion: v1
   kind: Service
   metadata:
     name: mcp-website-fetcher
     labels:
       app: mcp-website-fetcher
   spec:
     selector:
       app: mcp-website-fetcher
     ports:
     - port: 80
       targetPort: 8000
       appProtocol: kgateway.dev/mcp
   EOF
   ```

4. Create a Backend that sets up the agentgateway target details for the MCP fetcher tool. 

   ```yaml
   kubectl apply -f- <<EOF
   apiVersion: gateway.kgateway.dev/v1alpha1
   kind: Backend
   metadata:
     name: mcp-website-fetcher
   spec:
     type: MCP
     mcp:
       name: mcp-website-fetcher
       targets:
       - static:
           name: mcp-website-fetcher
           host: mcp-website-fetcher.default.svc.cluster.local
           port: 80
           protocol: SSE   
   EOF
   ```

## Step 2: Route with agentgateway {#agentgateway}

Route to the federated MCP servers with agentgateway.

1. Create a Gateway resource that uses the `agentgateway` GatewayClass. Kgateway automatically creates an agentgateway proxy for you.

   ```yaml
   kubectl apply -f- <<EOF
   apiVersion: gateway.networking.k8s.io/v1
   kind: Gateway
   metadata:
     name: agentgateway
   spec:
     gatewayClassName: {{< reuse "/docs/snippets/agw-gatewayclass.md" >}}
     listeners:
     - protocol: HTTP
       port: 8080
       name: http
       allowedRoutes:
         namespaces:
           from: All
   EOF
   ```

2. Verify that the Gateway is created successfully. You can also review the external address that is assigned to the Gateway. Note that depending on your environment it might take a few minutes for the load balancer service to be assigned an external address. If you are using a local Kind cluster without a load balancer such as `metallb`, you might not have an external address.

   ```sh
   kubectl get gateway agentgateway
   ```

   Example output: 
   
   ```txt
   NAME           CLASS          ADDRESS                                  PROGRAMMED   AGE
   agentgateway   agentgateway   1234567890.us-east-2.elb.amazonaws.com   True         93s
   ```

3. Create an HTTPRoute resource that routes to the Backends that you created in the previous step.

   ```yaml
   kubectl apply -f- <<EOF
   apiVersion: gateway.networking.k8s.io/v1
   kind: HTTPRoute
   metadata:
     name: mcp
   spec:
     parentRefs:
     - name: agentgateway
       namespace: default
     rules:
       - backendRefs:
         - name: mcp-server-everything
           group: gateway.kgateway.dev
           kind: Backend   
         - name: mcp-website-fetcher
           group: gateway.kgateway.dev
           kind: Backend   
   EOF
   ```

4. Check that the HTTPRoute is `Accepted`, selects the Gateway, and includes backend rules for both the Backends that you created.

   ```sh
   kubectl describe httproute mcp
   ```

   Example output:

   ```
   Name:         mcp
   Namespace:    default
   Labels:       <none>
   Annotations:  <none>
   API Version:  gateway.networking.k8s.io/v1
   Kind:         HTTPRoute
   Metadata:
     Creation Timestamp:  2025-08-11T16:16:16Z
     Generation:          1
     Resource Version:    13598
     UID:                    78f649b9-310e-4f21-ac0f-e516f06d8f22
   Spec:
     Parent Refs:
       Group:        gateway.networking.k8s.io
       Kind:         Gateway
       Name:         agentgateway
       Namespace:    default
     Rules:
       Backend Refs:
         Group:   gateway.kgateway.dev
         Kind:    Backend
         Name:    mcp-server-everything
         Weight:  1
         Group:   gateway.kgateway.dev
         Kind:    Backend
         Name:    mcp-website-fetcher
         Weight:  1
       Matches:
         Path:
           Type:   PathPrefix
           Value:  /
   Status:
     Parents:
       Conditions:
         Last Transition Time:  2025-08-11T16:16:16Z
         Message:               Route is accepted
         Observed Generation:   1
         Reason:                Accepted
         Status:                True
         Type:                  Accepted
         Last Transition Time:  2025-08-11T16:17:22Z
         Message:               Route has valid refs
         Observed Generation:   1
         Reason:                ResolvedRefs
         Status:                True
         Type:                  ResolvedRefs
       Controller Name:         kgateway.dev/kgateway
       Parent Ref:
         Group:  gateway.networking.k8s.io
         Kind:   Gateway
         Name:   agentgateway   
   ```


## Step 3: Verify the connection {#verify}

Use the [MCP Inspector tool](https://modelcontextprotocol.io/legacy/tools/inspector) to verify that you can connect to your federated MCP servers through agentgateway.

1. Get the agentgateway address.
   
   {{< tabs items="Cloud Provider LoadBalancer,Port-forward for local testing" tabTotal="2" >}}
   {{% tab tabName="Cloud Provider LoadBalancer" %}}
   ```sh
   export INGRESS_GW_ADDRESS=$(kubectl get gateway agentgateway -o=jsonpath="{.status.addresses[0].value}")
   echo $INGRESS_GW_ADDRESS
   ```
   {{% /tab %}}
   {{% tab tabName="Port-forward for local testing"%}}
   ```sh
   kubectl port-forward deployment/agentgateway 8080:8080
   ```
   {{% /tab %}}
   {{< /tabs >}}

2. From the terminal, run the MCP Inspector command. Then, the MCP Inspector opens in your browser.
   
   ```sh
   npx modelcontextprotocol/inspector#{{% reuse "docs/versions/mcp-inspector.md" %}}
   ```
   
3. From the MCP Inspector menu, connect to your agentgateway address as follows:
   * **Transport Type**: Select `Streamable HTTP`.
   * **URL**: Enter the agentgateway address and the `/mcp` path, such as `${INGRESS_GW_ADDRESS}/mcp` or `http://localhost:8080/mcp`.
   * Click **Connect**.

   {{< reuse-image src="img/mcp-inspector-connected.png" >}}
   {{< reuse-image-dark srcDark="img/mcp-inspector-connected-dark.png" >}}

4. From the menu bar, click the **Tools** tab. You should now see tools from both MCP servers:
   * **From `mcp-server-everything`**: Tools like `fetch`, `echo`, `random_number`, etc.
   * **From `mcp-server-everything-filesystem`**: Tools like `read_file`, `write_file`, `list_directory`, etc.

5. Test the federated tools:
   * **Test the `fetch` tool**: Click **List Tools** and select the `fetch` tool. In the **url** field, enter a website URL, such as `https://lipsum.com/`, and click **Run Tool**.
   * **Test the `list_directory` tool**: Click **List Tools** and select the `list_directory` tool. In the **path** field, enter `/tmp`, and click **Run Tool** to list the contents of the temporary directory.

## Cleanup

{{< reuse "docs/snippets/cleanup.md" >}}

```sh
kubectl delete Deployment mcp-server-everything mcp-website-fetcher
kubectl delete Service mcp-server-everything mcp-website-fetcher
kubectl delete Backend mcp-server-everything mcp-website-fetcher
kubectl delete Gateway agentgateway
kubectl delete HTTPRoute mcp
```

<!-- TODO CLI steps

You can verify the connection to the MCP server through a command line tool with `curl` requests or a user interface that is provided by the MCP Inspector tool.

### Curl requests in terminal {#cli}

1. Get the address of the Gateway for your MCP routes.
   
   {{< tabs items="Cloud Provider LoadBalancer,Port-forward for local testing" tabTotal="2"  >}}
   {{% tab tabName="Cloud Provider LoadBalancer" %}}
   ```sh
   export INGRESS_GW_ADDRESS=$(kubectl get svc -n default agentgateway -o jsonpath="{.status.loadBalancer.ingress[0]['hostname','ip']}")
   echo $INGRESS_GW_ADDRESS  
   ```
   {{% /tab %}}
   {{% tab tabName="Port-forward for local testing"  %}}
   ```sh
   kubectl port-forward deployment/agentgateway -n default 8080:8080
   ```
   {{% /tab %}}
   {{< /tabs >}}

2. Send a request through the Gateway to start a session.

   {{< tabs items="Cloud Provider LoadBalancer,Port-forward for local testing" tabTotal="2"  >}}
   {{% tab tabName="Cloud Provider LoadBalancer" %}}
   ```sh
   curl -v $INGRESS_GW_ADDRESS:8080/sse
   ```
   {{% /tab %}}
   {{% tab tabName="Port-forward for local testing"  %}}
   ```sh
   curl -v localhost:8080/sse
   ```
   {{% /tab %}}
   {{< /tabs >}}

   Example output:
   ```
   event: endpoint
   data: ?sessionId=c1a54dcb-be11-4f91-91b5-a1abf67deca2
   ```

3. Save the session ID from the output as an environment variable. In the example, the session ID is `c1a54dcb-be11-4f91-91b5-a1abf67deca2`.

   ```sh
   export SESSION_ID=c1a54dcb-be11-4f91-91b5-a1abf67deca2
   ``` 

4. Send a request to initialize the connection with your MCP server.

   {{< tabs items="Cloud Provider LoadBalancer,Port-forward for local testing" tabTotal="2" >}}
   {{% tab tabName="Cloud Provider LoadBalancer" %}}
   ```sh
   curl "$INGRESS_GW_ADDRESS:8080/mcp?sessionId=$SESSION_ID" -v \
     -H "Accept: text/event-stream,application/json" \
     --json '{"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{"roots":{}},"clientInfo":{"name":"claude-code","version":"1.0.60"}},"jsonrpc":"2.0","id":0}'
   ```
   {{% /tab %}}
   {{% tab tabName="Port-forward for local testing" %}}
   ```sh
   curl "http://localhost:8080/mcp?sessionId=$SESSION_ID" -v \
     -H "Accept: text/event-stream,application/json" \
     --json '{"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{"roots":{}},"clientInfo":{"name":"claude-code","version":"1.0.60"}},"jsonrpc":"2.0","id":0}'
   ```
   {{% /tab %}}
   {{< /tabs >}}

   **Note**: If you encounter connection issues, try using the MCP Inspector tool instead, which handles the protocol negotiation automatically.

### Browser-based MCP Inspector {#ui}

-->