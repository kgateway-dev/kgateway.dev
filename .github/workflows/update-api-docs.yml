name: Update Reference Documentation

on:
  workflow_dispatch:  # Allow manual triggers
    inputs:
      version:
        description: 'Version to generate docs for (e.g., "2.2.x", "2.1.x", "2.0.x") or "all" for all versions'
        required: true
        default: 'all'
        type: string
  release:  # Automatically trigger on new releases
    types: [published]

jobs:
  generate-api-docs:
    runs-on: ubuntu-latest

    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: Checkout docs repository
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/kgateway.dev
          path: kgateway.dev

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.24'
          cache: false

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install PyYAML
        run: pip install PyYAML

      - name: Parse versions from hugo.yaml
        run: |
          cd kgateway.dev
          python3 -c "
          import yaml
          import json
          
          with open('hugo.yaml', 'r') as f:
              config = yaml.safe_load(f)
          
          versions = config.get('params', {}).get('versions', [])
          version_data = []
          
          for version in versions:
              version_info = {
                  'version': version.get('version'),
                  'linkVersion': version.get('linkVersion'),
                  'url': version.get('url', '').lstrip('/')
              }
              version_data.append(version_info)
          
          print(json.dumps(version_data))
          " > versions.json
          
          echo "Parsed versions:"
          cat versions.json

      - name: Read max Kubernetes version
        run: |
          KUBE_VERSION=$(cat kgateway.dev/assets/docs/versions/max-kube.md | tr -d '\n')
          echo "KUBE_VERSION=$KUBE_VERSION" >> $GITHUB_ENV

      - name: Generate all documentation for selected version(s)
        run: |
          cd kgateway.dev
          
          # Process selected version(s) sequentially - generate all doc types per version
          python3 -c "
          import json
          import sys
          import subprocess
          import os
          import re
          
          def resolve_tag_for_version(version, link_version):
              '''Resolve the git tag to use for a given version (for release triggers)'''
              if link_version == 'main':
                  return 'main'
              
              # For other linkVersions, get the latest tag matching the version pattern
              try:
                  result = subprocess.run(['git', 'ls-remote', '--tags', '--sort=-version:refname', 'https://github.com/kgateway-dev/kgateway.git'], 
                                        capture_output=True, text=True, check=True)
                  if result.stdout.strip():
                      # Filter tags that match our version pattern
                      # Create regex pattern: 2.1.x becomes v2\.1\.\d+
                      version_pattern = version.replace('.x', r'\.\d+')
                      pattern = f'v{version_pattern}'
                      matching_tags = []
                      for line in result.stdout.strip().split('\n'):
                          if 'refs/tags/' in line:
                              tag_name = line.split('/')[-1]
                              if re.match(pattern, tag_name) and not any(suffix in tag_name for suffix in ['-rc', '-beta', '-main', '-agw']):
                                  matching_tags.append(tag_name)
                      
                      if matching_tags:
                          # Sort by version and take the latest
                          matching_tags.sort(key=lambda x: [int(n) for n in x.replace('v', '').split('.')], reverse=True)
                          return matching_tags[0]
                      else:
                          print(f'No stable tags found for version {version}')
                          return None
                  else:
                      print(f'No tags found in repository for version {version}')
                      return None
              except subprocess.CalledProcessError as e:
                  print(f'Error fetching tags for version {version}: {e}')
                  return None
          
          def resolve_branch_for_version(version, link_version):
              '''Resolve the git branch to use for a given version (for manual triggers)'''
              if link_version == 'main':
                  return 'main'
              
              # For other linkVersions, construct the branch name from the version
              # e.g., version "2.1.x" -> branch "v2.1.x"
              branch_name = f'v{version}'
              
              # Verify the branch exists in the remote repository
              try:
                  result = subprocess.run(['git', 'ls-remote', '--heads', 'https://github.com/kgateway-dev/kgateway.git', branch_name], 
                                        capture_output=True, text=True, check=True)
                  if result.stdout.strip():
                      print(f'   Found branch: {branch_name}')
                      return branch_name
                  else:
                      print(f'   Warning: Branch {branch_name} not found, trying to use it anyway')
                      # Still return the branch name - clone will fail if it doesn't exist
                      return branch_name
              except subprocess.CalledProcessError as e:
                  print(f'   Warning: Error checking branch {branch_name}: {e}')
                  # Still return the branch name - clone will fail if it doesn't exist
                  return branch_name
          
          def clone_repository(ref, kgateway_dir='kgateway'):
              '''Clone the kgateway repository at the specified branch or tag'''
              # Clean up any existing directory
              if os.path.exists(kgateway_dir):
                  subprocess.run(['rm', '-rf', kgateway_dir], check=True)
              
              # Clone repository
              if ref == 'main':
                  subprocess.run(['git', 'clone', '--branch', 'main', '--depth', '1', 'https://github.com/kgateway-dev/kgateway.git', kgateway_dir], check=True)
              else:
                  subprocess.run(['git', 'clone', '--depth', '1', '--branch', ref, 'https://github.com/kgateway-dev/kgateway.git', kgateway_dir], check=True)
          
          def generate_api_docs(version, link_version, url_path, kgateway_dir='kgateway'):
              '''Generate API reference documentation'''
              print(f'  ‚Üí Generating API docs for version {version}')
              
              # Check if the API directory exists
              api_path = f'{kgateway_dir}/api/v1alpha1/'
              if not os.path.exists(api_path):
                  print(f'    Warning: API directory {api_path} does not exist, skipping API docs')
                  return False
              
              # Generate API docs using individual subprocess calls
              subprocess.run(['envsubst'], input=open('scripts/crd-ref-docs-config.yaml').read(), text=True, stdout=open(f'crd-ref-docs-config-{link_version}.yaml', 'w'))
              
              subprocess.run([
                  'go', 'run', 'github.com/elastic/crd-ref-docs@v0.1.0',
                  f'--source-path={api_path}',
                  '--renderer=markdown',
                  '--output-path=./',
                  f'--config=crd-ref-docs-config-{link_version}.yaml'
              ], check=True)
              
              os.remove(f'crd-ref-docs-config-{link_version}.yaml')
              
              # Read the generated content once
              with open('./out.md') as f:
                  generated_content = f.read()
              
              os.remove('./out.md')
              
              # Generate docs for both envoy and agentgateway directories
              for doc_dir in ['envoy', 'agentgateway']:
                  target_path = f'content/docs/{doc_dir}/{url_path}/reference/'
                  os.makedirs(target_path, exist_ok=True)
                  
                  api_file = f'{target_path}api.md'
                  
                  # Create API reference file with frontmatter
                  with open(api_file, 'w') as f:
                      f.write('---\n')
                      f.write('title: API reference\n')
                      f.write('weight: 10\n')
                      f.write('---\n\n')
                      f.write(generated_content)
                  
                  # Format the generated docs with sed commands
                  subprocess.run(['sed', '-i', 's/Required: {}/Required/g', api_file], check=True)
                  subprocess.run(['sed', '-i', 's/Optional: {}/Optional/g', api_file], check=True)
                  subprocess.run(['sed', '-i', '/^# API Reference$/,/^$/d', api_file], check=True)
                  
                  # Additional post-processing to clean up complex struct types
                  import re
                  with open(api_file, 'r') as f:
                      content = f.read()
                  
                  # Replace complex struct type definitions with simple "struct"
                  # Pattern matches: _Underlying type:_ _[struct{...}...]_
                  content = re.sub(
                      r'_Underlying type:_ _\[struct\{[^\]]+\}\]\([^\)]+\)_',
                      '_Underlying type:_ _struct_',
                      content
                  )
                  
                  # Handle empty struct{} patterns
                  content = re.sub(
                      r'_Underlying type:_ _\[struct\{\}\]\(#struct\{\}\)_',
                      '_Underlying type:_ _struct_',
                      content
                  )
                  
                  # Also handle cases without the link wrapper
                  content = re.sub(
                      r'_Underlying type:_ _struct\{[^\}]+\}_',
                      '_Underlying type:_ _struct_',
                      content
                  )
                  
                  with open(api_file, 'w') as f:
                      f.write(content)
                  
                  print(f'    ‚úì Generated API docs in {api_file}')
              
              return True
          
          def generate_helm_docs(version, link_version, url_path, kgateway_dir='kgateway'):
              '''Generate Helm chart reference documentation'''
              print(f'  ‚Üí Generating Helm docs for version {version}')
              
              # Generate Helm docs for each chart
              charts = ['kgateway:kgateway', 'kgateway-crds:kgateway-crds']
              generated_any = False
              
              for chart in charts:
                  dir_name, file_name = chart.split(':')
                  helm_path = f'{kgateway_dir}/install/helm/{dir_name}'
                  
                  # Check if Helm directory exists
                  if not os.path.exists(helm_path):
                      print(f'    Warning: Helm directory {helm_path} does not exist, skipping {file_name}')
                      continue
                  
                  result = subprocess.run([
                      'go', 'run', 'github.com/norwoodj/helm-docs/cmd/helm-docs@v1.14.2',
                      f'--chart-search-root={helm_path}',
                      '--dry-run'
                  ], capture_output=True, text=True, check=True)
                  
                  # Write the raw helm-docs output to assets directory
                  # Use actual version numbers (2.2.x, 2.1.x, etc.) not linkVersion (main, latest)
                  # This prevents overwriting when promoting versions
                  assets_path = f'assets/docs/pages/reference/helm/{version}/'
                  os.makedirs(assets_path, exist_ok=True)
                  
                  helm_file = f'{assets_path}{file_name}.md'
                  
                  with open(helm_file, 'w') as f:
                      f.write(result.stdout)
                  
                  # Remove badge line and following empty line
                  subprocess.run(['sed', '-i', '/!\[Version:/,/^$/d', helm_file], check=True)
                  
                  # Remove backticks from the Default column in the table
                  subprocess.run(['sed', '-i', 's/| \`\([^\`]*\)\` |/| \1 |/g', helm_file], check=True)
                  
                  # Remove the title (# heading) and description lines from the top
                  # These will be hardcoded in the content files instead
                  # Remove lines 1-3 which contain: title, blank line, description
                  subprocess.run(['sed', '-i', '1,3d', helm_file], check=True)
                  
                  # Additional cleanup using Python to remove control characters and emojis
                  with open(helm_file, 'r', encoding='utf-8') as f:
                      content = f.read()
                  
                  # Remove ASCII control characters (0x00-0x1F) that helm-docs inserts for empty values
                  # These show as "SOH", "STX", etc. in editors but render as empty in browsers
                  # Also remove emojis and other special symbols
                  import unicodedata
                  cleaned_content = []
                  for char in content:
                      # Keep regular characters, newlines, tabs, and pipe symbols
                      if char in ['\n', '\t', '\r'] or ord(char) >= 32:
                          # Also filter out emoji/symbol unicode categories for table cells
                          if unicodedata.category(char)[0] != 'So' or char in [' ', '\n', '\t', '\r']:
                              cleaned_content.append(char)
                      # Skip control characters (ord < 32, except newline/tab/carriage return)
                  
                  content = ''.join(cleaned_content)
                  
                  # Add a note for charts with no configurable values (like kgateway-crds)
                  # Check if there's no Values section or no table
                  if '## Values' not in content or ('## Values' in content and '|-----|' not in content):
                      # Simply append the note to the end of the content
                      note = '\n\n{{< callout type="info" >}}\nNo configurable values are currently available for this chart.\n{{< /callout >}}\n'
                      content = content.rstrip() + note
                  
                  with open(helm_file, 'w', encoding='utf-8') as f:
                      f.write(content)
                  
                  print(f'    ‚úì Generated Helm docs in {helm_file}')
                  
                  generated_any = True
              
              return generated_any
          
          def generate_metrics_docs(version, link_version, url_path, kgateway_dir='kgateway'):
              '''Generate control plane metrics documentation'''
              print(f'  ‚Üí Generating metrics docs for version {version}')
              
              os.makedirs(f'assets/docs/snippets/{link_version}', exist_ok=True)
              
              # Check if metrics tool exists
              metrics_tool_path = f'{kgateway_dir}/pkg/metrics/cmd/findmetrics/main.go'
              if not os.path.exists(metrics_tool_path):
                  print(f'    Warning: Metrics tool {metrics_tool_path} does not exist, skipping metrics docs')
                  return False
              
              # Run the metrics finder tool
              result = subprocess.run([
                  'go', 'run', metrics_tool_path, 
                  '--markdown', f'./{kgateway_dir}'
              ], capture_output=True, text=True, check=True)
              
              with open(f'assets/docs/snippets/{link_version}/metrics-control-plane.md', 'w') as f:
                  f.write(result.stdout)
              
              print(f'    ‚úì Generated metrics docs in assets/docs/snippets/{link_version}/metrics-control-plane.md')
              return True
          
          # Main processing logic - determine target version
          is_release_trigger = '${{ github.event_name }}' == 'release'
          
          if is_release_trigger:
              # Release trigger: determine version from release tag
              release_tag = '${{ github.event.release.tag_name }}'
              print(f'üéâ Release trigger detected: {release_tag}')
              
              # Parse release tag (e.g., "v2.1.1") to version family (e.g., "2.1.x")
              if release_tag.startswith('v'):
                  version_parts = release_tag[1:].split('.')  # Remove 'v' and split
                  if len(version_parts) >= 2:
                      target_version = f'{version_parts[0]}.{version_parts[1]}.x'
                      print(f'üìã Mapped release {release_tag} to version family: {target_version}')
                  else:
                      print(f'‚ùå Invalid release tag format: {release_tag}')
                      sys.exit(1)
              else:
                  print(f'‚ùå Release tag does not start with "v": {release_tag}')
                  sys.exit(1)
          else:
              # Manual dispatch: use input version
              target_version = '${{ inputs.version }}'
              print(f'üë§ Manual trigger with version: {target_version}')
          
          with open('versions.json', 'r') as f:
              versions = json.load(f)
          
          # Filter versions based on target
          if target_version != 'all':
              all_versions = versions  # Keep original list for error reporting
              versions = [v for v in versions if v['version'] == target_version]
              if not versions:
                  print(f'‚ùå Version {target_version} not found in versions.json')
                  print(f'üìã Available versions: {[v["version"] for v in all_versions]}')
                  sys.exit(1)
          
          print(f'Processing {len(versions)} version(s): {[v[\"version\"] for v in versions]}')
          
          for version_info in versions:
              version = version_info['version']
              link_version = version_info['linkVersion']
              url_path = version_info['url']
              
              print(f'\nüîÑ Processing version: {version} (linkVersion: {link_version}, path: {url_path})')
              
              # Resolve tag or branch based on trigger type
              if is_release_trigger:
                  # Use tags for release triggers
                  ref = resolve_tag_for_version(version, link_version)
                  ref_type = 'tag'
              else:
                  # Use branches for manual triggers
                  ref = resolve_branch_for_version(version, link_version)
                  ref_type = 'branch'
              
              if not ref:
                  print(f'‚ùå Skipping version {version} - could not resolve {ref_type}')
                  continue
              
              print(f'   Using {ref_type}: {ref}')
              
              # Clone repository once per version
              try:
                  clone_repository(ref)
                  print(f'   ‚úì Cloned repository')
              except subprocess.CalledProcessError as e:
                  print(f'‚ùå Failed to clone repository for version {version}: {e}')
                  continue
              
              # Generate all documentation types for this version
              success_count = 0
              
              try:
                  if generate_api_docs(version, link_version, url_path):
                      success_count += 1
              except Exception as e:
                  print(f'   ‚ö† API docs failed: {e}')
              
              try:
                  if generate_helm_docs(version, link_version, url_path):
                      success_count += 1
              except Exception as e:
                  print(f'   ‚ö† Helm docs failed: {e}')
              
              try:
                  if generate_metrics_docs(version, link_version, url_path):
                      success_count += 1
              except Exception as e:
                  print(f'   ‚ö† Metrics docs failed: {e}')
              
              # Clean up repository after processing this version
              subprocess.run(['rm', '-rf', 'kgateway'], check=True)
              
              print(f'‚úÖ Completed version {version} - generated {success_count}/3 doc types')
          
          print('\nüéâ All versions processed!')
          "


      - name: Clean up temporary directories
        run: |
          cd kgateway.dev
          rm -rf kgateway

      - name: Create Pull Request
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          path: kgateway.dev
          commit-message: "docs: Update API, Helm, and Metrics reference docs${{ github.event_name == 'release' && format(' for release {0}', github.event.release.tag_name) || format(' for {0}', inputs.version == 'all' && 'all versions' || inputs.version) }}"
          signoff: true
          title: "Update API, Helm, and Metrics reference docs${{ github.event_name == 'release' && format(' for release {0}', github.event.release.tag_name) || format(' for {0}', inputs.version == 'all' && 'all versions' || inputs.version) }}"
          body: |
            ${{ github.event_name == 'release' && format('üéâ **Automated documentation update for release {0}**', github.event.release.tag_name) || format('üìù **Manual documentation update for {0}**', inputs.version == 'all' && 'all supported versions' || format('version {0}', inputs.version)) }}
            
            This PR updates API, Helm, and Metrics reference documentation based on the latest tags from the **kgateway** repository.
            
            **Trigger:** ${{ github.event_name == 'release' && 'üöÄ Release published' || 'üë§ Manual workflow dispatch' }}
            ${{ github.event_name == 'release' && format('**Release:** `{0}`', github.event.release.tag_name) || format('**Target version:** `{0}`', inputs.version) }}
            
            **Updates included:**
            - API reference documentation 
            - Helm chart reference documentation
            - Control plane metrics documentation
            - Each version uses the latest corresponding tag from the kgateway repository
            
            **File locations:**
            - API docs: `content/docs/{envoy,agentgateway}/{VERSION}/reference/api.md`
            - Helm docs: `assets/docs/pages/reference/helm/{VERSION}/` (included in content pages via `reuse` shortcode)
            - Metrics docs: `assets/docs/snippets/{VERSION}/metrics-control-plane.md`
          branch: api-gen-update
          branch-suffix: timestamp
          delete-branch: true
          base: main
          labels: |
            documentation
            automated pr